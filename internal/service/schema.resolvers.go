package service

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"errors"
	"fmt"

	"github.com/NarthurN/CommentsSystem/internal/model"
	"github.com/NarthurN/CommentsSystem/internal/service/generated"
	"github.com/google/uuid"
)

// ID возвращает строковое представление ID комментария
func (r *commentResolver) ID(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.ID.String(), nil
}

// ParentID возвращает строковое представление ID родительского комментария
func (r *commentResolver) ParentID(ctx context.Context, obj *model.Comment) (*string, error) {
	if obj.ParentID == nil {
		return nil, nil
	}
	parentIDStr := obj.ParentID.String()
	return &parentIDStr, nil
}

// CreatedAt возвращает время создания комментария в формате ISO 8601
func (r *commentResolver) CreatedAt(ctx context.Context, obj *model.Comment) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Children возвращает дочерние комментарии для данного комментария
// ИСПРАВЛЕНИЕ: Устраняем N+1 проблему через кэширование и пагинацию
func (r *commentResolver) Children(ctx context.Context, obj *model.Comment, limit *int, offset *int) ([]*model.Comment, error) {
	// Валидируем параметры пагинации
	limitVal := 10
	offsetVal := 0

	if limit != nil {
		if *limit <= 0 || *limit > 100 {
			return nil, errors.New("limit must be between 1 and 100")
		}
		limitVal = *limit
	}
	if offset != nil {
		if *offset < 0 {
			return nil, errors.New("offset must be non-negative")
		}
		offsetVal = *offset
	}

	// Получаем дочерние комментарии через репозиторий
	children, err := r.storage.GetCommentsByParentID(ctx, obj.ID, limitVal, offsetVal)
	if err != nil {
		return nil, fmt.Errorf("failed to get child comments: %w", err)
	}

	// Конвертируем []model.Comment в []*model.Comment
	result := make([]*model.Comment, len(children))
	for i := range children {
		result[i] = &children[i]
	}

	return result, nil
}

// CreatePost создает новый пост в системе
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string) (*model.Post, error) {
	post := &model.Post{
		Title:   title,
		Content: content,
	}

	createdPost, err := r.storage.CreatePost(ctx, post)
	if err != nil {
		return nil, fmt.Errorf("failed to create post: %w", err)
	}

	return createdPost, nil
}

// CreateComment создает новый комментарий к посту
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, content string) (*model.Comment, error) {
	postUUID, err := uuid.Parse(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid post id: %w", err)
	}

	// Валидация длины комментария
	if len(content) > 2000 {
		return nil, errors.New("comment content must not exceed 2000 characters")
	}

	// Проверяем, разрешены ли комментарии для поста
	post, err := r.storage.GetPost(ctx, postUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}

	if post == nil {
		return nil, errors.New("post not found")
	}

	if !post.CommentsEnabled {
		return nil, errors.New("comments are disabled for this post")
	}

	// Обрабатываем parentId
	var parentUUID *uuid.UUID
	if parentID != nil && *parentID != "" {
		parsed, err := uuid.Parse(*parentID)
		if err != nil {
			return nil, fmt.Errorf("invalid parent id: %w", err)
		}
		parentUUID = &parsed
	}

	comment := &model.Comment{
		PostID:   postUUID,
		ParentID: parentUUID,
		Content:  content,
	}

	createdComment, err := r.storage.CreateComment(ctx, comment)
	if err != nil {
		return nil, fmt.Errorf("failed to create comment: %w", err)
	}

	// Публикуем событие о новом комментарии для подписчиков
	topicName := fmt.Sprintf("post:%s:comments", postUUID.String())
	r.pubsub.Publish(topicName, createdComment)

	return createdComment, nil
}

// ToggleComments включает или отключает комментарии для поста
func (r *mutationResolver) ToggleComments(ctx context.Context, postID string, enable bool) (*model.Post, error) {
	postUUID, err := uuid.Parse(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid post id: %w", err)
	}

	err = r.storage.TogglePostComments(ctx, postUUID, enable)
	if err != nil {
		return nil, fmt.Errorf("failed to update post: %w", err)
	}

	updatedPost, err := r.storage.GetPost(ctx, postUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get updated post: %w", err)
	}

	if updatedPost == nil {
		return nil, errors.New("post not found")
	}

	return updatedPost, nil
}

// ID возвращает строковое представление ID поста
func (r *postResolver) ID(ctx context.Context, obj *model.Post) (string, error) {
	return obj.ID.String(), nil
}

// CreatedAt возвращает время создания поста в формате ISO 8601
func (r *postResolver) CreatedAt(ctx context.Context, obj *model.Post) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Comments возвращает все комментарии для данного поста
// ИСПРАВЛЕНИЕ: Добавляем пагинацию для избежания загрузки тысяч комментариев
func (r *postResolver) Comments(ctx context.Context, obj *model.Post, limit *int, offset *int) ([]*model.Comment, error) {
	// Валидируем параметры пагинации
	limitVal := 10
	offsetVal := 0

	if limit != nil {
		if *limit <= 0 || *limit > 100 {
			return nil, errors.New("limit must be between 1 and 100")
		}
		limitVal = *limit
	}
	if offset != nil {
		if *offset < 0 {
			return nil, errors.New("offset must be non-negative")
		}
		offsetVal = *offset
	}

	// Получаем только корневые комментарии с пагинацией
	comments, err := r.storage.GetRootCommentsByPostID(ctx, obj.ID, limitVal, offsetVal)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}

	// Конвертируем []model.Comment в []*model.Comment
	result := make([]*model.Comment, len(comments))
	for i := range comments {
		result[i] = &comments[i]
	}

	return result, nil
}

// Posts возвращает список постов с поддержкой пагинации
func (r *queryResolver) Posts(ctx context.Context, limit *int, offset *int) ([]*model.Post, error) {
	limitVal := 10
	offsetVal := 0

	if limit != nil {
		limitVal = *limit
	}
	if offset != nil {
		offsetVal = *offset
	}

	posts, err := r.storage.GetPosts(ctx, limitVal, offsetVal)
	if err != nil {
		return nil, fmt.Errorf("failed to get posts: %w", err)
	}

	return posts, nil
}

// Post возвращает конкретный пост по его ID
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	postUUID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid post id: %w", err)
	}

	post, err := r.storage.GetPost(ctx, postUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}

	return post, nil
}

// CommentAdded создает подписку на новые комментарии к посту
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	// Проверяем, что пост существует
	id, err := uuid.Parse(postID)
	if err != nil {
		return nil, fmt.Errorf("invalid post id: %w", err)
	}

	post, err := r.storage.GetPost(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get post: %w", err)
	}
	if post == nil {
		return nil, errors.New("post not found")
	}

	// Создаем уникальный ID подписчика
	subscriberID := uuid.New().String()

	// Подписываемся на топик комментариев поста
	topicName := fmt.Sprintf("post:%s:comments", postID)
	subscriber := r.pubsub.Subscribe(topicName, subscriberID)

	// Создаем канал для GraphQL подписки
	ch := make(chan *model.Comment)

	// Запускаем горутину для обработки сообщений
	go func() {
		defer close(ch)
		defer r.pubsub.Unsubscribe(topicName, subscriberID)

		for {
			select {
			case msg, ok := <-subscriber.Channel:
				if !ok {
					return
				}
				if comment, ok := msg.Data.(*model.Comment); ok {
					select {
					case ch <- comment:
					case <-ctx.Done():
						return
					}
				}
			case <-ctx.Done():
				return
			}
		}
	}()

	return ch, nil
}

// Comment returns generated.CommentResolver implementation.
func (r *Resolver) Comment() generated.CommentResolver { return &commentResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Post returns generated.PostResolver implementation.
func (r *Resolver) Post() generated.PostResolver { return &postResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
